\chapter{System Integration}

\section{System Architecture}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{figures/5.1.png}
    \caption{FPGA system architecture block diagram.}
    \label{fig:sys_diagram}
\end{figure}

The pulse channel is an integral component of an FPGA system designed to generate 32 pulsed AC voltage signals and 32 static voltage signals. This system leverages both the processing systems and the programmable logic of the ZCU102 architecture. A Python-based interface allows users to input specific information about the pulses and voltage signals. This interface translates user requests into custom commands, which are then sent to the processing system via the FPGA's UART interface.

The processing system's ARM-based CPU processes these Python-generated commands, converting them into addresses and data instructions for the FPGA's blocks. Within the FPGA hardware, a router takes the byte-addressable data from the processing system and translates it into block-specific word-addressable data, directing it to the appropriate block. The system comprises three distinct hardware blocks, each serving a unique and critical function. The orange blocks in \autoref{fig:sys_diagram} illustrate the names of these blocks, which will be discussed in detail in the subsequent sections.

This architecture ensures efficient communication and data processing within the FPGA system, enhancing its overall performance and reliability. By understanding the roles and interactions of these components, students can appreciate the complexity and precision required in FPGA and computer architecture design.

\section{CPU Interface}

The system utilizes a CPU interface adapter to bridge between the PS and the PL. This adapter plays a crucial role by converting byte-addressed signals from the PS AXI bus into a 32-bit word-addressed bus, which is essential for the proper functioning of the blocks within the FPGA design. Illustrated in \autoref{table:ps_addr}, the upper bits of the PS address are decoded to select one of the three available blocks in the system. Notably, the interface is designed to support up to four blocks, allowing for future expansion. Once a block is selected, the lower bits of the address, along with the data, are used to either write to or read from the chosen block. This ensures precise and efficient communication between the PS and the selected block. Additionally, a standardized register interface is implemented to provide consistent access for control and status monitoring, thereby enhancing the system's reliability and ease of use. By employing this CPU interface adapter, the system achieves seamless integration between the PS and PL, facilitating efficient data transfer and control across the FPGA design. This design choice not only simplifies the communication process but also ensures scalability and flexibility for future enhancements.

 
% TODO: HOW TF do I properly set the addr table in latex....
\begin{table}
\centering
\caption{Address convert format}
\includegraphics[width=1.0\textwidth]{figures/pc_address.png}
\label{table:ps_addr}
\end{table}
\section{Static DC Voltage}
% TODO: replace with a clear picture
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{figures/5.2.png}
    \caption{Block diagram for the DC voltage module}
    \label{fig:dc}
\end{figure}
The DC block provides stable and programmable static voltage control using four Analog Device AD5286 PMOD DACs. Each DAC supports eight voltage channels, making a total of 32 channels, as illustrated in \autoref{fig:dc}. Communication between the DACs and the system occurs via the SPI interface. These SPI interfaces are implemented as separate modules, each managing the clock, data, and chip select signals for data transmission to the DACs.

% TODO: Again... latex is not great for hardware so far...
\begin{table}[h]
\centering

\caption{SPI DAC message format [XX]}
% \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
% \hline
% 31 & 28 & 24 & 22 & & & \multicolumn{1}{l}{8} & \multicolumn{1}{l}{7} & \multicolumn{1}{r}{0} \\
% \hline
% 0 & Update DAC & 0 & \multicolumn{2}{|c|}{Channel select} & \multicolumn{2}{|c|}{Data} & 0 \\
% \hline
% \end{tabular}
\includegraphics[width=1.0\textwidth]{figures/spi_addr.png}
\label{table:spi_addr}
\end{table}

The module supports write operations to update DAC channels and control features such as internal reference voltage and power. It also supports read operations, which return status flags for each SPI transaction. Upon selection, the DC block converts part of the address and the lower 12-bit data from the processing system into SPI command as defined in \autoref{table:spi_addr}. The processing system provides a 12-bit positive integer value for the DACs, which is then converted to an actual voltage value as specified by:

\begin{equation}
V_{out} = V_{ref} \times \frac{D}{2^{12}}
\end{equation}

Where $V_{out}$ is the voltage output by the DAC, $V_{ref}$ is the DAC's reference voltage, and $D$ is the data from the processing system [XX]. This design ensures precise and flexible static voltage control. The use of multiple DACs and independent SPI modules allows for efficient handling of numerous voltage channels, providing enhanced control and reliability.

\section{Pulse Generation and Management}

The pulse generation module—also referred to as the AC block—is a sophisticated, synchronous multi-channel pulsed waveform generator designed to deliver precise control for laser operations on phonetic chips. Its architecture generates pulse sequences with a remarkable 10-nanosecond resolution across 32 channels, ensuring that each digital output is perfectly synchronized. This synchronization proves essential for high-speed digital-to-analog conversion, enabling accurate reconstruction of analog signals in the time-sensitive quantum applications.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{figures/5.3.png}
    \caption{Block Diagram of the AC block.}
    \label{fig:george}
\end{figure}
The AC block acts as the central coordinator for all pulse channels. A Central Coordinator Process (CC-P) manages both external control signals and error notifications from individual channels, ensuring reliable overall performance. Central to its operation is a 24-bit counter that functions as a common timer, as seen in \autoref{fig:george}. Upon receiving an external trigger, this counter initiates the timing process uniformly for all channels. It continues until it reaches either a user-defined sequence length or its maximum value, at which point it sends stop signals to halt pulse generation. This coordinated stopping mechanism is critical because it maintains timing precision and prevents runaway pulses that could lead to data inconsistencies.

A series of internal registers underpin the module's functionality. These registers store key parameters such as the total sequence length, the active channels, and the specific data paths for channel memories reading and writing operations. Values are loaded into these registers via the CPU interface, which streams configuration data from the processing system. The design supports simultaneous writing to multiple channels, an essential feature for updating waveform parameters in parallel. However, because the data bus is only 32 bits wide, the system restricts read operations to one channel at a time, thereby preserving data integrity during retrieval.

The module also incorporates an innovative addressing scheme that clearly distinguishes between channel-specific memory and internal control registers. The lower address range is reserved for waveform data and precise pulse parameters, while the upper range is dedicated to registers for the CC-P. Registers for settings such as sequence length, channel enables, and channel selections are both readable and writable. This bidirectional access permits real-time control and monitoring of each channel, facilitating adjustments as operational conditions change. In contrast, dedicated read-only registers continuously convey status information from both the module and the individual pulse channels.

Error handling within the AC block is equally streamlined. As discussed in section X, each pulse channel generates error signals that are collected as multi-bit vectors. The CC-P then transposes these into several 32-bit registers, with each register corresponding to a specific error type as defined in \autoref{table:erro_regs}. Within a given register, each bit represents the status of an error flag for one of the 32 channels. This systematic condensation of error information into a single-dimensional format simplifies monitoring and debugging processes, enabling engineers to quickly identify and address issues.

Overall, the AC block's design is both concise and modular. Its synchronized timing, robust control through internal registers, and innovative addressing scheme collectively ensure accurate pulse generation and efficient error management. By abstracting complex hardware interactions into a well-organized, user-friendly format, this module not only improves system reliability but also provides a clear insight into its operation for students and professionals alike, bridging the gap between sophisticated hardware design and practical application.

\section{Miscellaneous}

The miscellaneous block is a versatile control and status interface integrated into the system. It manages a variety of auxiliary functions that streamline control processes. This module organizes essential operations, such as managing system interfacing, monitoring status, and distributing control signals. Its primary role is to bridge CPU control with hardware functionality through several dedicated registers. These registers handle tasks such as version reporting, LED indication, and debug routing. A notable feature is its configurable LED control system. This system allows either CPU software or FPGA hardware to drive status indicators based on the LED enable register settings, providing flexibility and accurate control. By establishing a robust boundary between software and hardware domains, the module ensures comprehensive system control while maintaining clear architectural separation. Isolating these auxiliary functions enhances maintainability, simplifies debugging, and promotes reusability. Beyond its fundamental capabilities, the miscellaneous block streamlines operations and supports a modular system architecture.

\section{Software Control Interface}

A robust software interface is as crucial as the FPGA hardware itself for system success. The dedicated Python package translates user-defined waveform values and pulse information into precise addresses and data formats that the hardware readily interprets. This abstraction bridges the gap between users with limited hardware design experience and the intricate nature of FPGA architectures. By automating tasks such as memory management and data formatting, the system enables users to focus on refining their quantum control strategies rather than wrestling with low-level operations. This design philosophy enhances both usability and performance across the entire framework.

The interface functions much like a streamlined web API, allowing users to submit waveform data and update parameters seamlessly. For every entry, the software automatically locates the next available memory space, computes the starting address and length, and allocates the data accordingly—returning a unique waveform ID for straightforward reference. This methodical allocation ensures that inputs accumulate properly and that any error due to exceeding available memory is promptly flagged. Additionally, the system archives each waveform record in a dedicated file, providing traceability as detailed in \autoref{table:param_rec_table}.

\begin{table}[h]
\centering
\caption{Sample Format of the Waveform Record}
\label{table:param_rec_table}
\begin{tabular}{|c|c|c|c|c|}
\hline
channel 0 & val 0 & val 1 & ... & val N \\
\hline
channel 1 & val 0 & val 1 & ... & val N \\
\hline
\multicolumn{5}{|c|}{...} \\
\hline
channel 31 & val 0 & val 1 & ... & val N \\
\hline
\end{tabular}
\end{table}

In a similar fashion, pulse parameter management is performed through dedicated functions that support both loading and retrieval. Unlike waveform data, which can vary in length and address, pulse parameters are stored in fixed groups of four values. Users provide essential details such as the pulse's start time, time factor, gain factor, and sustain time, along with the relevant waveform ID. The interface then leverages this ID to fetch additional hardware parameters—such as the corresponding waveform's start address and length—converting the user inputs into a hardware-accepted format as outlined in \autoref{fig:pd}b. Corresponding records are then logged in a file following the format shown in \autoref{table:wave_rec_table}

\begin{table}[h]
\centering
\caption{Sample Format of the Pulse Parameter Record (2 channels shown)}
\label{table:wave_rec_table}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Channel 0 & wave ID & Start time & Time factor & Gain factor & Sustain time \\
\hline
Channel 1 & wave ID & Start time & Time factor & Gain factor & Sustain time \\
\hline
\end{tabular}
\end{table}

After processing, the serial interface passes these hardware-ready values to a custom Python class that integrates them with precise control subroutines designed for the FPGA. Communication with the embedded ARM CPU is maintained via a UART connection, with the third-party PYSerial package ensuring reliable data transfer. Commands transmitted by the Python class are interpreted by the ARM CPU to activate specific design blocks, as defined in \autoref{fig:sys_diagram}. This layered control strategy not only streamlines user interaction but also preserves the precision and high performance required by contemporary FPGA applications.