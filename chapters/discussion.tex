\chapter{Discussion}

\section{Hardware Precision}

The current FPGA-based control system for quantum laser control demonstrates proof-of-concept functionality and lays a foundation for future applications. However, test results reveal consistent discrepancies between theoretical and measured values. These errors stem primarily from the rounding mechanism. \autoref{fig:block_diagram} indicates that data and address inputs in the waveform table memory are floored to the nearest integer, which discards important fractional components and limits resolution.

Waveforms are generated from predefined tables that are externally computed and then loaded into the system. This method simplifies on-chip logic and resource management by avoiding complex dynamic computations. However, using a fixed 16-bit integer representation introduces quantization errors when multiple write operations produce a complete waveform. The resulting trade-off between simplicity and precision underscores the limitations of the current design. To improve accuracy, enhanced rounding methods, such as midpoint rounding or adaptive precision schemes, could reduce truncation errors. Adopting dynamic waveform generation lowers the data transfer volume. In this approach, only key parameters—amplitude, frequency, and phase—are specified. The system computes the complete waveform in real time. This method produces waveforms that more closely match their theoretical definitions. The reduced data transfer volume also lowers storage and communication overhead.

\section{Hardware Error Handling}

The system utilizes a basic error detection framework that effectively identifies invalid parameters from the user. When an error occurs, the system sets a status flag for the controlling processor to read. However, it relies on a passive notification system rather than active error recovery. This approach depends entirely on a dedicated software interface to resolve issues, which can lead to complications if the software is not properly implemented or if user parameter conversions fail.

The pulse channel's definition memory assumes waveform parameters are provided in a consecutive, incrementing order. The hardware lacks a built-in mechanism to verify or correct this order. The module directly maps the provided address to the memory, which can lead to data inconsistencies if users do not sequence their parameters correctly. Future development should introduce a hardware mechanism to enforce cumulative writes of pulse parameters.

Additionally, permitting users to write to any memory location enhances system flexibility but also introduces the risk of overlapping writes. Without rigorous external software control over memory address management, the probability of data overwrites increases. Addressing this vulnerability in future work at the hardware level helps to maintain system stability and reliability.

% Subjected for removal if alternate firmware implemented
\section{Interface Latency}
% TODO: this is only the idea for new implementation... will get modified a lot after the new interface is done
Many user-level interfaces are implemented in Python on a separate PC, requiring UART serial writes to the hardware system. Each write transmits only 8 bits of data from the host to the FPGA, resulting in limited throughput and extended read and write times. Tests show that reading and writing an entire waveform and one pulse configuration each take an average of three to four seconds. These delays become significant bottlenecks, especially when the system needs to access memories multiple times during operation.

To mitigate this issue, sophisticated C firmware could replace much of Python's functionality in the future. This firmware would reside on Xilinx's processing system, fully leveraging Zynq's high-speed AXI interface to accelerate data transfers. Instead of relying on Python functions to relay user parameters, the processing system would accept input directly from a command-line interface. Users could manually type parameters or design scripts to automate their entry.